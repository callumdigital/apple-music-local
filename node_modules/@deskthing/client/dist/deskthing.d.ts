import { Action, ActionReference, App, AppSettings, ClientManifest, DEVICE_CLIENT, KeyReference, LOGGING_LEVELS, SocketData, SongData, ClientToDeviceData, TransitData, DeviceToClientData } from "@deskthing/types";
type BaseData = TransitData<string, string, unknown>;
type ExtractDeviceType<D extends BaseData> = D["type"] | DEVICE_CLIENT;
type ExtractDeviceRequest<D extends BaseData, T extends ExtractDeviceType<BaseData>> = Extract<DeviceToClientData, {
    type: T;
}>["request"] | Extract<D, {
    type: T;
}>["request"];
type ExtractDevicePayload<B extends BaseData, T extends ExtractDeviceType<B>, R extends ExtractDeviceRequest<B, T> | undefined> = Extract<DeviceToClientData, {
    type: T;
    request?: R;
}> extends never ? Extract<B, {
    type: T;
    request?: R;
}> : Extract<DeviceToClientData, {
    type?: T;
    request?: R;
}>;
type LinkListener<D extends BaseData, T extends ExtractDeviceType<D>, R extends ExtractDeviceRequest<D, T>, P extends undefined | never = never> = (payload: ExtractDevicePayload<D, T, R> | P) => void | Promise<void>;
export declare class DeskThingClass<ToClientData extends BaseData = SocketData, ToAppData extends BaseData = SocketData> {
    private static instance;
    private manifest;
    private listeners;
    private onceListenerKeys;
    private keyOverrides;
    /**
     * Initializes the DeskThing instance and sets up event listeners.
     * Sends a message to the parent indicating that the client has started.
     * Also sets up a click event listener for buttons.
     * @version 0.10.4
     */
    constructor();
    /**
     * Initializes the message event listener.
     * @private
     * @version 0.10.4
     */
    private initialize;
    /**
     * Sets up the listeners and bubbles them to the server
     * @private
     * @version 0.10.4
     */
    private initializeListeners;
    /**
   * Prevents default DeskThing handling for specific keys
   * @param keys - Array of key codes to override (e.g., ['KeyA', 'Enter', 'Space'])
   * @example
   * deskThing.overrideKeys(['KeyA', 'Enter', 'Scroll']);
   */
    overrideKeys(keys: string[]): void;
    /**
     * Removes key overrides
     * @param keys - Array of key codes to restore default
     * @example
     * deskThing.restoreKeys(['KeyA', 'Enter', 'Scroll']);
     */
    restoreKeys(keys: string[]): void;
    /**
     * Singleton pattern: Ensures only one instance of DeskThing exists.
     * @returns {DeskThingClass} The single instance of DeskThing
     * @version 0.10.4
     *
     * @example
     * const deskThing = DeskThing.getInstance();
     */
    static getInstance<T extends SocketData = SocketData, S extends SocketData = SocketData>(): DeskThingClass<T, S>;
    /**
     * Registers an event listener for a specific event type.
     * @param {string} type - The type of event to listen for
     * @param {EventCallback} callback - The function to call when the event occurs
     * @returns {Function} A function to remove the event listener
     * @version 0.10.4
     *
     * @example
     * const removeListener = deskThing.on('music', (data: SocketData) => {
     *   console.log('Received music data:', data.payload);
     * });
     *
     * @example
     * // Client-side code (here)
     * const removeListener = deskThing.on('customdata', (data: SocketData) => {
     *   console.log('Received custom data:', data.payload);
     * });
     *
     * // Server-side code
     * DeskThing.send({ type: 'customdata', payload: 'Hello from the server!' });
     */
    on<E extends DEVICE_CLIENT | ToClientData["type"]>(type: E, callback: LinkListener<ToClientData, E, string>): () => void;
    /**
     * Removes an event listener for a specific event type.
     * @param {string} type - The type of event to remove the listener from
     * @param {EventCallback} callback - The function to remove from the listeners
     * @version 0.10.4
     *
     * @example
     * deskThing.off('message', messageCallback);
     */
    off<E extends DEVICE_CLIENT | ToClientData["type"]>(type: E, callback: LinkListener<ToClientData, E, string>): void;
    /**
     * Handles incoming messages from the parent window.
     * @param {MessageEvent} event - The message event received
     * @private
     * @version 0.10.4
     */
    private handleMessage;
    /**
     * Emits an event to all registered listeners for that event type.
     * @param {string} type - The type of event to emit
     * @param {SocketData} data - The data to pass to the event listeners
     * @returns {Promise<void>}
     * @private
     * @version 0.10.4
     */
    private emit;
    /**
     * Listens for a single occurrence of an event, then removes the listener
     * @param {string} type - The event type to listen for
     * @param {EventCallback} callback - The function to call when the event occurs
     * @returns {Function} - Function to manually remove the listener
     * @version 0.10.4
     *
     * @example
     * deskThing.once('music', (data) => {
     *   console.log('Received music data:', data.payload);
     * });
     *
     * @example
     * // Client-side code (here)
     * deskThing.once('data', (data) => {
     *   console.log('Received specific request:', data.payload); // prints Payload 3 once
     * }, 'specificRequest');
     *
     *  // Server-side code
     * DeskThing.send({ type: 'data', payload: 'Payload 1', request: 'someRequest' }); // Wont send
     * DeskThing.send({ type: 'data', payload: 'Payload 2', request: 'randomRequest' }); // Wont send
     * DeskThing.send({ type: 'data', payload: 'Payload 3', request: 'specificRequest' }); // Will send
     * DeskThing.send({ type: 'data', payload: 'Payload 4', request: 'faultyRequest' }); // Wont send
     * DeskThing.send({ type: 'data', payload: 'Payload 5', request: 'specificRequest' }); // Wont send
     */
    once<T extends ExtractDeviceType<ToClientData>, R extends ExtractDeviceRequest<ToClientData, T>>(type: T, callback: (data: ExtractDevicePayload<ToClientData, T, R>) => void, request?: R): () => void;
    /**
     * Asynchronously waits for a response after sending a request to the client
     * @param {SocketData} requestData - The data to send to initiate the request
     * @param {SocketData} listenFor - The response data pattern to listen for
     * @param {Function?} callback - Optional callback function to handle the response
     * @returns {Promise<t | undefined>} - The retrieved data still wrapped in its payload, or undefined if the request fails or times out after 5 seconds
     * @version 0.10.4
     *
     * This will automatically return the payload of the response.
     *
     * @example
     * // On the client
     * const data = await DeskThing.fetch<UserProfile>(
     *            { type: 'get', request: 'profile', payload: { userId: '123' } },
     *            { type: 'users', request: 'update' }
     *         );
     *
     * console.log(data.payload); // prints the user profile data
     *
     * // On the server
     * DeskThing.on('get', (data) => {
     *  if (data.request == 'profile') {
     *    DeskThing.send({
     *      type: 'users',
     *      payload: users.getUserById(data.payload.userId),
     *      request: 'update'
     *    })
     *  }
     * }
     *
     * @example
     * // On the client
     * DeskThing.fetch<UserProfile>(
     *   { type: 'get', request: 'profile', payload: { userId: '123' } },
     *   { type: 'users', request: 'update' }
     *   async (userData) => {{
     *      console.log(userData.payload); // prints the user profile data
     *   }
     * );
     *
     *
     * // On the server
     * DeskThing.on('get', (data) => {
     *  if (data.request == 'profile') {
     *    DeskThing.send({
     *      type: 'users',
     *      payload: users.getUserById(data.payload.userId),
     *      request: 'update'
     *    })
     *  }
     * }
     */
    fetch: <T extends ExtractDeviceType<ToClientData>, R extends Extract<ToClientData, {
        type: T;
    }>["request"] | string>(requestData: ToAppData | ClientToDeviceData, listenFor?: {
        type: T;
        request?: R;
    }, callbackFn?: (data: ExtractDevicePayload<ToClientData, T, R> | undefined) => void) => Promise<ExtractDevicePayload<ToClientData, T, R> | undefined>;
    /**
     * @deprecated Use {@link DeskThing.fetch} instead
     * Asynchronously waits for a response after sending a request to the client
     * @param {string} type - The type to listen to
     * @param {SocketData} requestData - The data to send that will be listened to
     * @param {string?} request (optional) A specific request to listen for
     * @returns {Promise<t | undefined>} - The retrieved data, or undefined if the request fails or times out after 5 seconds
     * @version 0.10.4
     *
     * This will automatically return the payload of the response.
     *
     * @example
     * // On the client
     * const data = await deskThing.fetchData<UserProfile>('users', {
     *   type: 'get',
     *   request: 'profile',
     *   payload: { userId: '123' }
     * });
     * console.log(data); // prints the user profile data
     *
     * // On the server
     * DeskThing.on('get', (data) => {
     *  if (data.request == 'profile') {
     *    DeskThing.send({
     *      type: 'users',
     *      payload: users.getUserById(data.payload.userId)
     *    })
     *  }
     * }
     */
    fetchData: <T, E extends string = string>(type: string, requestData: Extract<ClientToDeviceData | ToAppData, {
        type: E;
    }>, request?: string) => Promise<T | undefined>;
    /**
     * Requests and waits for music data from the server
     * @returns {Promise<SongData | undefined>} - The retrieved music data, or undefined if the request fails
     * @version 0.10.4
     *
     * @example
     * const musicData = await deskThing.getMusic();
     * if (musicData) {
     *   console.log('Current song:', musicData.song_title);
     * }
     */
    getMusic: () => Promise<SongData | undefined>;
    /**
     * Requests and waits for application settings from the server
     * @returns {Promise<AppSettings | undefined>} - The retrieved settings, or undefined if the request fails
     * @version 0.10.4
     *
     * @example
     * const settings = await deskThing.getSettings();
     * if (settings) {
     *   console.log('Theme:', settings.theme.value);
     *   console.log('Language:', settings.language.value);
     * }
     */
    getSettings: () => Promise<AppSettings | undefined>;
    /**
     * Requests and waits for the list of installed apps from the server
     * @returns {Promise<App[] | undefined>} - The retrieved apps list, or undefined if the request fails
     * @version 0.10.4
     *
     * @example
     * const installedApps = await deskThing.getApps();
     * if (installedApps) {
     *   installedApps.forEach(app => {
     *     console.log('App name:', app.name);
     *   });
     * }
     */
    getApps: () => Promise<App[] | undefined>;
    /**
     * Returns the URL for the action mapped to the key. Usually, the URL points to an SVG icon.
     * @param KeyReference
     * @returns {Promise<string | undefined>} - The URL for the action icon, or undefined if the request fails
     * @version 0.10.4
     */
    getKeyIcon: (KeyReference: KeyReference) => Promise<string | undefined>;
    /**
     * Returns the URL for the action . Usually, the URL points to an SVG icon.
     * @param action
     * @returns {Promise<string | undefined>} - The URL for the action icon, or undefined if the request fails
     * @version 0.10.4
     */
    getActionIcon: (action: Action | ActionReference) => Promise<string | undefined>;
    /**
     * Triggers an action as if it were triggered by a button
     * @param {ActionReference} action - The action to trigger
     * @param {string} action.id - The ID of the action
     * @param {string} [action.value] - Optional value for the action
     * @param {string} [action.source] - Optional source of the action (defaults to current app)
     * @version 0.10.4
     *
     * @example
     * // Trigger a simple action
     * deskThing.triggerAction({ id: 'do-something' });
     *
     * // Trigger an action with a value and custom source
     * deskThing.triggerAction({
     *   id: 'volup',
     *   value: '15',
     *   source: 'server'
     * });
     *
     * @example
     * // Trigger an action that modifies the client
     * deskThing.triggerAction({
     *   id: 'appslist',
     *   value: 'show',
     *   source: 'server'
     * });
     *
     * @example
     * // Trigger an action on your app
     * deskThing.triggerAction({
     *   id: 'service',
     *   value: 'restart'
     * });
     *
     * // Server-side code
     * DeskThing.on('action', (action) => {
     *   if (action.id === 'service') {
     *     console.log(action.value); // prints restart
     *   }
     * });
     */
    triggerAction: (action: Omit<ActionReference, "source" | "enabled"> & {
        source?: string;
        enabled?: boolean;
    }) => Promise<void>;
    /**
     * Triggers the action tied to a specific key
     * @param {KeyReference} KeyReference - The key trigger configuration
     * @param {string} KeyReference.key - The key to trigger
     * @param {EventMode} KeyReference.mode - The event mode (e.g., 'keydown', 'keyup')
     * @param {string} [KeyReference.source] - Optional source of the key trigger (defaults to current app)
     *
     * @example
     * // Trigger a keydown event
     * deskThing.triggerKey({
     *   key: 'Enter',
     *   mode: EventMode.KeyDown,
     *   source: 'server'
     * });
     *
     * // Trigger a keyup event with custom source
     * deskThing.triggerKey({
     *   key: 'Escape',
     *   mode: EventMode.PressLong,
     *   source: 'server'
     * });
     */
    triggerKey: (KeyReference: Omit<KeyReference, "source"> & {
        source?: string;
    }) => Promise<void>;
    /**
     * Returns the manifest of the server
     * @returns {Promise<ClientManifest | undefined>} The manifest of the server, or undefined if the request fails
     */
    getManifest: () => Promise<ClientManifest | undefined>;
    /**
     * Formats an image URL to make the returned string a usable src for an image
     * @param image - A legacy-acceptable image url that can be either base64 OR a url
     * @returns - a usable URL
     * @depreciated - use {@link DeskThing.useProxy} instead
     * @example
     * //server
     * DeskThing.on('getImage', (socketData: SocketData) => {
     *    const imageUrl = await DeskThing.saveImageReferenceFromURL('https://host.com/some/image/url.png')
     *    DeskThing.send({ type: 'image', payload: imageUrl || '' })
     * })
     *
     * // client
     * const imageUrl = await DeskThing.fetchData<string>('image', { type: 'getImage' })
     * const formattedImage = DeskThing.formatImageUrl(imageUrl)
     * return <img src={formattedImage} alt="Image" />
     * @example
     * //server
     * const imageUrl = await DeskThing.saveImageReferenceFromURL(settings.image.value)
     * DeskThing.send({ type: 'image', payload: imageUrl || '' })
     *
     * // client
     * const [image, setImage] = useState<string>('')
     * const imageUrl = await DeskThing.on('image', (imageUrl) => {
     *   const formattedImage = DeskThing.formatImageUrl(imageUrl)
     *   setImage(formattedImage)
     * })
     * return <img src={image} alt="Image" />
     */
    formatImageUrl: (image: string) => string;
    /**
     * Use the proxy to fetch an image from the server
     *
     * version 1
     *
     * @param url - The url to fetch
     * @returns - The proxied url that can be used to fetch the image
     * @example
     * const imageUrl = DeskThing.useProxy('https://example.com/image.png')
     * return <img src={imageUrl} alt="Image" />
     */
    useProxy: (url: string) => string;
    /**
     * Sends a message to the parent window.
     * @param {SocketData} data - The data to send to the parent. "app" defaults to the current app
     * @deprecated Use send() instead
     * @example
     * deskThing.sendMessageToParent({
     *   app: 'client',
     *   type: 'action',
     *   payload: { buttonClicked: 'submit' }
     * });
     */
    sendMessageToParent(data: ToAppData & {
        app?: string;
    }): void;
    /**
     * Sends a message to the parent window.
     * @param {SocketData} data - The data to send to the parent. "app" defaults to the current app
     *
     * @example
     * deskThing.send({
     *   app: 'client',
     *   type: 'action',
     *   payload: { buttonClicked: 'submit' }
     * });
     */
    send(data: (ClientToDeviceData | ToAppData) & {
        app?: string;
    }): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.log(LOGGING_LEVELS.INFO, 'This is an info message', 'this is extra data');
     * // logs "[CLIENT]: This is an info message this is extra data" to the console
     * // logs "[YourApp] This is an info message" to the client
     * // logs "[CLIENT.YourApp] This is an info message" to the server
     */
    log(level: LOGGING_LEVELS, message: string, ...extraData: any[]): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.error('This is an error message', 'this is extra data');
     * // logs "[CLIENT]: This is an error message this is extra data" to the console
     * // logs "[YourApp] This is an error message" to the client
     * // logs "[CLIENT.YourApp] This is an error message" to the server
     */
    error(message: string, ...extraData: any[]): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.warn('This is a warning message', 'this is extra data');
     * // logs "[CLIENT]: This is a warning message this is extra data" to the console
     * // logs "[YourApp] This is a warning message" to the client
     * // logs "[CLIENT.YourApp] This is a warning message" to the server
     */
    warn(message: string, ...extraData: any[]): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.debug('This is a debug message', 'this is extra data');
     * // logs "[CLIENT]: This is a debug message this is extra data" to the console
     * // logs "[YourApp] This is a debug message" to the client
     * // logs "[CLIENT.YourApp] This is a debug message" to the server
     */
    debug(message: string, ...extraData: any[]): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.fatal('This is a fatal message', 'this is extra data');
     * // logs "[CLIENT]: This is a fatal message this is extra data" to the console
     * // logs "[YourApp] This is a fatal message" to the client
     * // logs "[CLIENT.YourApp] This is a fatal message" to the server
     */
    fatal(message: string, ...extraData: any[]): void;
    /**
     * Logs the message in the console, the client, and the server
     * The extra data logged will not be bubbled anywhere but the console
     *
     * @example
     * DeskThing.info('This is an info message', 'this is extra data');
     * // logs "[CLIENT]: This is an info message this is extra data" to the console
     * // logs "[YourApp] This is an info message" to the client
     * // logs "[CLIENT.YourApp] This is a fatal message" to the server
     */
    info(message: string, ...extraData: any[]): void;
}
/**
/**
  * Creates a new instance of the DeskThing class
  * @template CustomIncomingData Type for data that can be received from the socket, defaults to SocketData
  * @template CustomOutgoingData Type for data that can be sent through the socket, defaults to SocketData
  * @returns A new instance of the DeskThing class with specified generic types
  * @example
  * // Basic usage with default types
  * const deskThing = createDeskThing();
  *
  * // Usage with custom types
  * interface MyListenData { message: string }
  * interface MySendData { status: boolean }
  * const customDeskThing = createDeskThing<MyListenData, MySendData>();
  *
  * @example
  * // Very complex usage with strong typing
  *
  * // Define types
  * type CustomIncomingData = {
  *   type: 'someData';
  *   request?: 'opt1' | 'opt2';
  *   payload: 'someWantedReturnedData'
  * }
  *
  * type CustomOutgoingData = {
  *   type: 'getSomeData';
  *   request?: 'opt1' | 'opt2';
  *   payload: 'someOtherData'
  * }
  *
  * // Create the deskthing object
  * const dk = createDeskThing<CustomIncomingData, CustomOutgoingData>();
  *
  * // ex async function for awaiting
  * const d = async () => {
  *
  *   // using the fetch() method - everything is strongly typed
  *   const data = await dk.fetch({
  *     type: 'getSomeData',
  *     request: 'opt1',
  *     payload: 'someOtherData'
  *   }, {
  *     type: 'someData',
  *     request: 'opt1',
  *   }, (data) => {
  *     // optional callback hook. data will be 'someWantedReturnedData'
  *     return data
  *   })
  *
  *   // data will be 'someWantedReturnedData'
  *   console.log(data)
  *
  *   const settings = await dk.fetch({
  *     type: CLIENT_REQUESTS.GET,
  *     request: 'settings',
  *     app: 'client'
  *   }, {
  *     type: DEVICE_CLIENT.SETTINGS,
  *   }, (data) => {
  *
  *     console.log('From the callback function', data)
  *   })
  *
  *   data
  *
  * }
  */
export declare function createDeskThing<CustomIncomingData extends SocketData = SocketData, CustomOutgoingData extends SocketData = SocketData>(): DeskThingClass<CustomIncomingData, CustomOutgoingData>;
/**
 * The DeskThing instance.
 * Only use for utility-functions like encoding images or sending logs
 *
 * Do not use for any data fetching/listening, instead use {@link createDeskThing}
 *
 * @example
 * import { DeskThing } from "@deskthing/client";
 *
 * DeskThing.sendInfo('This is an info message', 'this is extra data');
 */
export declare const DeskThing: DeskThingClass<SocketData, SocketData>;
export {};
